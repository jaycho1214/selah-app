---
phase: 05-feed-engagement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/feed/feed-skeleton.tsx
  - components/feed/feed-list.tsx
autonomous: true

must_haves:
  truths:
    - "Feed shows shimmer skeleton cards while loading instead of a spinner"
    - "Skeleton cards match the visual shape of real post cards"
  artifacts:
    - path: "components/feed/feed-skeleton.tsx"
      provides: "Shimmer skeleton card placeholders for feed loading state"
      min_lines: 60
    - path: "components/feed/feed-list.tsx"
      provides: "Reusable feed list component with FlashList, pagination, pull-to-refresh, and skeleton loading"
      min_lines: 100
  key_links:
    - from: "components/feed/feed-skeleton.tsx"
      to: "react-native-reanimated"
      via: "shimmer animation with useSharedValue + withRepeat"
      pattern: "withRepeat.*withTiming"
    - from: "components/feed/feed-list.tsx"
      to: "react-relay"
      via: "usePaginationFragment for infinite scroll"
      pattern: "usePaginationFragment"
---

<objective>
Create the skeleton loading component and a reusable feed list component that both For You and Following tabs will share.

Purpose: The existing posts.tsx uses an ActivityIndicator spinner for loading. Per user decision, skeleton card placeholders (3-4 shimmer cards) must replace the spinner. Extracting a shared feed list component avoids code duplication when adding the dual-tab structure in Plan 02.

Output: Two new components -- FeedSkeleton for loading states and FeedList for paginated feed rendering with FlashList.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-feed-engagement/05-CONTEXT.md
@.planning/phases/05-feed-engagement/05-RESEARCH.md

@components/bible/chapter-skeleton.tsx
@components/verse/reflection-item.tsx
@app/(tabs)/posts.tsx
@hooks/use-colors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FeedSkeleton component with shimmer cards</name>
  <files>components/feed/feed-skeleton.tsx</files>
  <action>
Create a FeedSkeleton component that renders 3-4 shimmer skeleton cards matching the visual shape of ReflectionItem post cards. Follow the exact same shimmer pattern used in `components/bible/chapter-skeleton.tsx`:

1. Use `useSharedValue(0)` with `withRepeat(withTiming(1, { duration: 1200 }), -1, false)` for the shimmer animation
2. Create a `ShimmerBar` inner component using `useAnimatedStyle` with `interpolate(shimmer.value, [0, 0.5, 1], [0.4, 0.7, 0.4])` for opacity
3. Use `useColors()` hook for theme-aware colors (not inline dark/light detection like ChapterSkeleton -- use colors.surfaceElevated for the shimmer bar base color)

Each skeleton card should visually match ReflectionItem layout:
- Left side: 44x44 circle (avatar placeholder)
- Right side column:
  - Row: short bar (name ~100px), dot, shorter bar (username ~70px), dot, tiny bar (time ~30px)
  - 2-3 lines of varying width content bars (e.g., 95%, 80%, 60%)
  - Bottom row: 3 small circles for action buttons (like, comment, share)

Render 4 cards with the border separator between them matching `borderBottomWidth: StyleSheet.hairlineWidth`.

Props: `{ style?: ViewStyle }` so it can be used with different paddings.

The component should be wrapped in a View, not a ScrollView (it will be used as a Suspense fallback inside the tab).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
Visually inspect the component renders correctly by temporarily importing it.
  </verify>
  <done>FeedSkeleton renders 4 shimmer cards with avatar circle, header bars, content lines, and action button placeholders using the established Reanimated shimmer pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Create shared FeedList component</name>
  <files>components/feed/feed-list.tsx</files>
  <action>
Extract the core feed list logic from `app/(tabs)/posts.tsx` into a reusable `FeedList` component. This component will be used by both For You and Following tabs in Plan 02.

The component should accept these props:
```typescript
interface FeedListProps {
  fragmentRef: FeedListFragment$key;  // The pagination fragment key
  connectionKey: string;  // Relay connection key for edge deletion
}
```

However, because Relay fragments are tightly coupled to their query, use a different approach: Make FeedList a component that receives the data and callbacks, NOT the Relay fragment itself. This keeps Relay wiring in the parent.

Props:
```typescript
interface FeedListProps {
  posts: ReadonlyArray<{
    readonly node: {
      readonly id: string;
      readonly content?: string | null;
      readonly createdAt: string;
      readonly likesCount: number;
      readonly childPostsCount: number;
      readonly likedAt?: string | null;
      readonly user: { readonly id: string; readonly name?: string | null; readonly username?: string | null; readonly image?: { readonly url?: string | null } | null };
      readonly images: ReadonlyArray<{ readonly url?: string | null; readonly width?: number | null; readonly height?: number | null }>;
      readonly poll?: { readonly id: string; readonly totalVotes?: number | null; readonly isExpired?: boolean | null; readonly userVote?: { readonly id?: string | null; readonly text?: string | null } | null; readonly options?: ReadonlyArray<{ readonly id: string; readonly text?: string | null; readonly voteCount?: number | null; readonly votePercentage?: number | null }> | null } | null;
      readonly verse?: { readonly id?: string | null; readonly book?: string | null; readonly chapter?: number | null; readonly verse?: number | null; readonly translation?: string | null } | null;
    };
  }>;
  isRefreshing: boolean;
  isLoadingNext: boolean;
  hasNext: boolean;
  onRefresh: () => void;
  onLoadMore: () => void;
  onLike: (id: string) => void;
  onUnlike: (id: string) => void;
  onDelete: (id: string) => void;
  currentUserId: string | null;
  emptyState?: React.ReactNode;  // Custom empty state component
  contentContainerStyle?: { paddingTop?: number; paddingBottom?: number };
}
```

Implementation:
- Use FlashList with the same configuration as posts.tsx (onEndReachedThreshold 0.5, keyExtractor by node.id)
- Render each item via ReflectionItem with the same props mapping as posts.tsx (including verse reference derivation from BIBLE_BOOK_DETAILS)
- Staggered fade-in animation: ReflectionItem already has `FadeIn.duration(200).delay(index * 25)` -- this is sufficient per the existing pattern
- RefreshControl with colors from useColors()
- Loading footer with ActivityIndicator when isLoadingNext
- If posts array is empty, render the emptyState prop (or a default empty message)
- The `collapsable={false}` prop must be on the container View for Android PagerView compatibility

Export `FeedList` as the default export.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.
Verify the component exports are correct and can be imported.
  </verify>
  <done>FeedList component exists with FlashList, RefreshControl, pagination footer, empty state support, and Android collapsable={false} -- ready for both For You and Following tabs to use.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `components/feed/feed-skeleton.tsx` exists and exports FeedSkeleton
- `components/feed/feed-list.tsx` exists and exports FeedList
- FeedSkeleton uses Reanimated shimmer pattern matching ChapterSkeleton
- FeedList uses FlashList with ReflectionItem rendering
</verification>

<success_criteria>
- FeedSkeleton renders 4 shimmer cards matching ReflectionItem visual layout
- FeedList provides a reusable paginated feed with FlashList, pull-to-refresh, and infinite scroll
- Both components compile without TypeScript errors
- No new dependencies needed (uses existing Reanimated, FlashList, useColors)
</success_criteria>

<output>
After completion, create `.planning/phases/05-feed-engagement/05-01-SUMMARY.md`
</output>
