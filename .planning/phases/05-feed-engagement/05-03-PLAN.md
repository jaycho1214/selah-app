---
phase: 05-feed-engagement
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/verse/reflection-item.tsx
autonomous: true

must_haves:
  truths:
    - "User can tap a poll option to vote"
    - "After voting, poll transitions from options to results view"
    - "Results show vote percentages and the user's selected option is highlighted"
    - "Vote is optimistically updated (selected option highlighted immediately)"
    - "User receives haptic feedback when voting"
  artifacts:
    - path: "components/verse/reflection-item.tsx"
      provides: "Poll voting with confirm-then-reveal pattern and optimistic updates"
      min_lines: 600
  key_links:
    - from: "components/verse/reflection-item.tsx"
      to: "GraphQL pollVote mutation"
      via: "useMutation with optimistic updater"
      pattern: "pollVote.*optionId.*pollId"
    - from: "components/verse/reflection-item.tsx"
      to: "expo-haptics"
      via: "haptic feedback on vote"
      pattern: "Haptics.*impactAsync"
---

<objective>
Wire up poll voting mutation in ReflectionItem so users can vote on polls and see results update in real-time.

Purpose: The poll display already exists in ReflectionItem (shows results when userVote or isExpired), but there is no vote mutation -- tapping an option does nothing when the poll hasn't been voted on yet. This plan adds the pollVote mutation with the confirm-then-reveal pattern per user decision.

Output: Updated ReflectionItem with working poll vote functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-feed-engagement/05-CONTEXT.md
@.planning/phases/05-feed-engagement/05-RESEARCH.md

@components/verse/reflection-item.tsx
@app/(tabs)/posts.tsx
@app/post/[id].tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add poll vote mutation with confirm-then-reveal pattern</name>
  <files>components/verse/reflection-item.tsx</files>
  <action>
Add poll voting functionality to the ReflectionItem component. The GraphQL schema has:
- `pollVote(optionId: ID!, pollId: ID!): PollVotePayload!`
- `pollUnvote(pollId: ID!): PollUnvotePayload!`
- PollVotePayload returns `poll` with `totalVotes`, `userVote`, `options` (with `voteCount`, `votePercentage`)

**Changes to ReflectionItem:**

1. **Add new props for poll voting:**
   ```typescript
   onPollVote?: (pollId: string, optionId: string) => void;
   ```
   However, since ReflectionItem is used in many places and we want to keep it self-contained, handle the mutation INSIDE ReflectionItem instead. Import `useMutation` from react-relay and define the mutation inline.

2. **Define GraphQL mutations (inside the file, before the component):**
   ```graphql
   mutation reflectionItemPollVoteMutation($optionId: ID!, $pollId: ID!) {
     pollVote(optionId: $optionId, pollId: $pollId) {
       poll {
         id
         totalVotes
         userVote {
           id
           text
         }
         options {
           id
           text
           voteCount
           votePercentage
         }
       }
     }
   }
   ```

   NOTE on naming: The file is `reflection-item.tsx`, so the Relay convention requires the mutation name prefix to be `reflectionItem` (camelCase of the filename). This matches the established project pattern.

3. **Poll voting state inside ReflectionItem:**
   - `const [selectedOptionId, setSelectedOptionId] = useState<string | null>(null)` -- tracks the option being confirmed
   - `const [commitPollVote, isPollVoting] = useMutation(PollVoteMutation)`

4. **Confirm-then-reveal pattern (per user decision):**
   - When poll is unvoted and not expired:
     - Tapping an option: Set `selectedOptionId` to that option's id, highlight it with accent background briefly
     - After a short delay (~300ms using setTimeout), execute the vote mutation
     - Show optimistic result immediately (selected option highlighted, percentages estimated)
   - When poll is already voted or expired: Show results (existing behavior)
   - The "brief highlight" before transition: use the selectedOptionId state to apply a temporary accent background to the selected option before results show

5. **Optimistic updater for poll vote:**
   ```typescript
   optimisticUpdater: (store) => {
     const pollRecord = store.get(poll.id);
     if (pollRecord) {
       // Set userVote
       const userVoteRecord = store.create(`client:userVote:${optionId}`, 'PollOption');
       userVoteRecord.setValue(optionId, 'id');
       userVoteRecord.setValue(selectedOption?.text ?? '', 'text');
       pollRecord.setLinkedRecord(userVoteRecord, 'userVote');

       // Increment totalVotes
       const currentTotal = (pollRecord.getValue('totalVotes') as number) ?? 0;
       pollRecord.setValue(currentTotal + 1, 'totalVotes');

       // Update the voted option's voteCount
       const options = pollRecord.getLinkedRecords('options');
       if (options) {
         for (const opt of options) {
           const optId = opt.getValue('id');
           if (optId === optionId) {
             const currentVotes = (opt.getValue('voteCount') as number) ?? 0;
             opt.setValue(currentVotes + 1, 'voteCount');
           }
           // Don't try to recalculate percentages -- let server response fix them
         }
       }
     }
   }
   ```

6. **Update the poll rendering section:**
   Currently the poll section has:
   ```jsx
   const showResults = poll.isExpired || !!poll.userVote;
   ```
   Change to:
   ```jsx
   const showResults = poll.isExpired || !!poll.userVote || selectedOptionId !== null;
   ```

   For the option press handler:
   ```jsx
   <Pressable
     key={option.id}
     onPress={() => {
       if (!showResults && !isPollVoting) {
         handlePollVote(option.id);
       }
     }}
     disabled={showResults || isPollVoting}
     style={[styles.pollOption, { borderColor: colors.border }]}
   >
   ```

7. **handlePollVote function:**
   ```typescript
   const handlePollVote = useCallback((optionId: string) => {
     if (!poll) return;
     Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
     setSelectedOptionId(optionId);

     // Short delay for the "confirm" visual, then execute mutation
     setTimeout(() => {
       commitPollVote({
         variables: { optionId, pollId: poll.id },
         optimisticUpdater: (store) => { /* as described above */ },
         onError: (error) => {
           console.error('Poll vote failed:', error);
           setSelectedOptionId(null);  // Reset on error
         },
       });
     }, 200);
   }, [poll, commitPollVote]);
   ```

8. **Visual highlight for selected option:**
   In the poll option rendering, when `selectedOptionId === option.id` AND we haven't received server results yet, show the option with accent background:
   ```jsx
   const isSelected = selectedOptionId === option.id;
   // Add to the pollOption style:
   isSelected && !poll.userVote && { backgroundColor: colors.accent + '15' }
   ```

9. **Run relay-compiler** after adding the new GraphQL mutation to generate types:
   ```bash
   npx relay-compiler
   ```

10. **Import the generated type** and type the mutation properly.
  </action>
  <verify>
Run `npx relay-compiler` -- should complete without errors.
Run `npx tsc --noEmit` -- should compile without type errors.
Open a post with a poll that hasn't been voted on -- tapping an option should:
1. Briefly highlight the selected option
2. Transition to results view showing percentages
3. Selected option should be visually distinguished
  </verify>
  <done>
Users can vote on polls by tapping an option. The confirm-then-reveal pattern works:
1. Tap option -> brief highlight -> results appear with percentages
2. Optimistic update shows immediately (selected option highlighted, vote count incremented)
3. Server response corrects percentages
4. Haptic feedback fires on vote
5. Error handling resets state if vote fails
  </done>
</task>

</tasks>

<verification>
- `npx relay-compiler` passes with new pollVote mutation
- `npx tsc --noEmit` passes
- Poll options are tappable when unvoted and not expired
- Tapping an option triggers haptic feedback
- Selected option briefly highlights before showing results
- Results show correct percentages and vote counts
- User's voted option is visually distinguished
- Expired polls still show results correctly (no regression)
- Already-voted polls show results correctly (no regression)
</verification>

<success_criteria>
- Poll voting works end-to-end with optimistic updates
- Confirm-then-reveal visual pattern is smooth
- No regression in poll display for expired or already-voted polls
- TypeScript and Relay compilation pass
- Haptic feedback fires on vote action
</success_criteria>

<output>
After completion, create `.planning/phases/05-feed-engagement/05-03-SUMMARY.md`
</output>
