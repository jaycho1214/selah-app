---
phase: 03-bible-reading
plan: 09
type: execute
wave: 5
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - components/bible/font-size-picker.tsx
  - components/bible/translation-picker.tsx
  - components/bible/download-manager.tsx
  - lib/bible/offline.ts
  - app/bible/[book]/[chapter].tsx
autonomous: true

must_haves:
  truths:
    - "User can adjust font size (small/medium/large)"
    - "Font size persists across sessions"
    - "User can download a translation for offline use"
    - "Downloaded translation works without network"
  artifacts:
    - path: "components/bible/font-size-picker.tsx"
      provides: "Font size selection UI"
      exports: ["FontSizePicker"]
    - path: "lib/bible/offline.ts"
      provides: "Offline Bible data management"
      exports: ["downloadTranslation", "isTranslationDownloaded", "getOfflineVerses"]
  key_links:
    - from: "components/bible/font-size-picker.tsx"
      to: "lib/stores/settings-store.ts"
      via: "useSettingsStore"
      pattern: "useSettingsStore"
    - from: "lib/bible/offline.ts"
      to: "lib/db/client.ts"
      via: "db for SQLite operations"
      pattern: "import.*db.*from"
    - from: "lib/bible/offline.ts"
      to: "expo-file-system"
      via: "FileSystem.downloadAsync"
      pattern: "FileSystem"
---

<objective>
Implement font size adjustment and offline reading with translation downloads.

Purpose: Font size accessibility (BIBL-07) and offline reading (BIBL-08, BIBL-09) are essential for a Bible app. Users read in various conditions and may not always have network.

Output: Font size picker, translation download manager, offline-first data loading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-bible-reading/03-RESEARCH.md
@.planning/phases/03-bible-reading/03-01-SUMMARY.md
@.planning/phases/03-bible-reading/03-02-SUMMARY.md
@.planning/phases/03-bible-reading/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FontSizePicker component</name>
  <files>components/bible/font-size-picker.tsx</files>
  <action>
Create `components/bible/font-size-picker.tsx`:

```typescript
import { View, Text, Pressable } from 'react-native';
import { useSettingsStore, FontSize, FONT_SIZES } from '@/lib/stores/settings-store';

const FONT_SIZE_OPTIONS: { id: FontSize; label: string }[] = [
  { id: 'small', label: 'A' },
  { id: 'medium', label: 'A' },
  { id: 'large', label: 'A' },
];

interface FontSizePickerProps {
  onClose?: () => void;
}

export function FontSizePicker({ onClose }: FontSizePickerProps) {
  const { fontSize, setFontSize } = useSettingsStore();

  const handleSelect = (size: FontSize) => {
    setFontSize(size);
    onClose?.();
  };

  return (
    <View className="p-4">
      <Text className="text-foreground text-base font-semibold mb-3">
        Font Size
      </Text>
      <View className="flex-row gap-3">
        {FONT_SIZE_OPTIONS.map((option) => {
          const sizes = FONT_SIZES[option.id];
          const isSelected = fontSize === option.id;
          return (
            <Pressable
              key={option.id}
              onPress={() => handleSelect(option.id)}
              className={`flex-1 py-3 rounded-lg items-center justify-center ${
                isSelected ? 'bg-primary' : 'bg-muted'
              }`}
            >
              <Text
                className={isSelected ? 'text-primary-foreground' : 'text-foreground'}
                style={{ fontSize: sizes.text }}
              >
                {option.label}
              </Text>
              <Text
                className={`text-xs mt-1 ${
                  isSelected ? 'text-primary-foreground/70' : 'text-muted-foreground'
                }`}
              >
                {option.id}
              </Text>
            </Pressable>
          );
        })}
      </View>

      {/* Preview */}
      <View className="mt-4 p-3 bg-muted rounded-lg">
        <Text className="text-muted-foreground text-xs mb-1">Preview</Text>
        <Text
          className="text-foreground"
          style={{
            fontSize: FONT_SIZES[fontSize].text,
            lineHeight: FONT_SIZES[fontSize].lineHeight,
          }}
        >
          For God so loved the world, that he gave his only begotten Son...
        </Text>
      </View>
    </View>
  );
}
```

The picker shows three size options with live preview. The selected size is highlighted and persists via the settings store.
  </action>
  <verify>
- File exports `FontSizePicker` component
- Three size options (small, medium, large)
- Uses useSettingsStore for state
- Preview shows current font size
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>FontSizePicker component for text size adjustment</done>
</task>

<task type="auto">
  <name>Task 2: Create offline Bible data manager</name>
  <files>lib/bible/offline.ts</files>
  <action>
Install expo-file-system if not already:
```bash
npx expo install expo-file-system
```

Create `lib/bible/offline.ts`:

```typescript
import * as FileSystem from 'expo-file-system';
import { db } from '@/lib/db/client';
import { translations, verses } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import type { BibleBook } from './types';

const API_URL = process.env.EXPO_PUBLIC_API_URL ?? 'https://api.selah.app';

export interface DownloadProgress {
  status: 'idle' | 'downloading' | 'processing' | 'complete' | 'error';
  progress: number; // 0-100
  error?: string;
}

/**
 * Check if a translation is downloaded for offline use
 */
export async function isTranslationDownloaded(translationId: string): Promise<boolean> {
  const result = await db
    .select()
    .from(translations)
    .where(eq(translations.id, translationId))
    .limit(1);
  return result.length > 0 && result[0].downloadedAt !== null;
}

/**
 * Get list of downloaded translations
 */
export async function getDownloadedTranslations() {
  return db.select().from(translations);
}

/**
 * Download a translation for offline use
 * Note: This requires a bulk Bible data endpoint on the server.
 * If that doesn't exist, this will need to be modified to fetch chapter-by-chapter.
 */
export async function downloadTranslation(
  translationId: string,
  onProgress?: (progress: DownloadProgress) => void
): Promise<void> {
  try {
    onProgress?.({ status: 'downloading', progress: 0 });

    // Download Bible data JSON
    // Expected format: { name: string, verses: Array<{ book, chapter, verse, text }> }
    const url = `${API_URL}/api/bible/${translationId}.json`;
    const fileUri = `${FileSystem.cacheDirectory}${translationId}.json`;

    const downloadResult = await FileSystem.downloadAsync(url, fileUri, {
      md5: false,
    });

    if (downloadResult.status !== 200) {
      throw new Error(`Download failed with status ${downloadResult.status}`);
    }

    onProgress?.({ status: 'processing', progress: 50 });

    // Read and parse the file
    const content = await FileSystem.readAsStringAsync(downloadResult.uri);
    const data = JSON.parse(content) as {
      name: string;
      verses: Array<{
        book: BibleBook;
        chapter: number;
        verse: number;
        text: string;
      }>;
    };

    // Insert into SQLite in batches
    const batchSize = 500;
    const totalVerses = data.verses.length;

    for (let i = 0; i < totalVerses; i += batchSize) {
      const batch = data.verses.slice(i, i + batchSize);

      await db.transaction(async (tx) => {
        for (const v of batch) {
          await tx
            .insert(verses)
            .values({
              id: `${translationId}:${v.book}:${v.chapter}:${v.verse}`,
              translationId,
              book: v.book,
              chapter: v.chapter,
              verse: v.verse,
              text: v.text,
            })
            .onConflictDoUpdate({
              target: verses.id,
              set: { text: v.text },
            });
        }
      });

      const progress = 50 + Math.round((i / totalVerses) * 50);
      onProgress?.({ status: 'processing', progress });
    }

    // Mark translation as downloaded
    await db
      .insert(translations)
      .values({
        id: translationId,
        name: data.name,
        downloadedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: translations.id,
        set: { downloadedAt: new Date() },
      });

    // Cleanup temp file
    await FileSystem.deleteAsync(fileUri, { idempotent: true });

    onProgress?.({ status: 'complete', progress: 100 });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    onProgress?.({ status: 'error', progress: 0, error: message });
    throw error;
  }
}

/**
 * Delete a downloaded translation
 */
export async function deleteTranslation(translationId: string): Promise<void> {
  await db.delete(verses).where(eq(verses.translationId, translationId));
  await db.delete(translations).where(eq(translations.id, translationId));
}

/**
 * Get verses from offline storage
 */
export async function getOfflineVerses(
  translationId: string,
  book: BibleBook,
  chapter: number
) {
  return db
    .select()
    .from(verses)
    .where(
      eq(verses.translationId, translationId) &&
      eq(verses.book, book) &&
      eq(verses.chapter, chapter)
    )
    .orderBy(verses.verse);
}

/**
 * Check if specific chapter is available offline
 */
export async function isChapterAvailable(
  translationId: string,
  book: BibleBook,
  chapter: number
): Promise<boolean> {
  const result = await db
    .select({ id: verses.id })
    .from(verses)
    .where(
      eq(verses.translationId, translationId) &&
      eq(verses.book, book) &&
      eq(verses.chapter, chapter)
    )
    .limit(1);
  return result.length > 0;
}
```

Note: This implementation assumes the server has a `/api/bible/{translation}.json` endpoint that returns bulk Bible data. If that endpoint doesn't exist, the backend may need to be updated, or we can implement a chapter-by-chapter download approach.
  </action>
  <verify>
- File exports download/query functions
- Uses expo-file-system for downloads
- Uses Drizzle db for SQLite operations
- Handles progress callbacks
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Offline Bible data manager with download and query functions</done>
</task>

<task type="auto">
  <name>Task 3: Integrate font size and translation picker into reader</name>
  <files>components/bible/translation-picker.tsx, app/bible/[book]/[chapter].tsx</files>
  <action>
Create `components/bible/translation-picker.tsx`:

```typescript
import { useState, useEffect } from 'react';
import { View, Text, Pressable, ActivityIndicator } from 'react-native';
import { Check, Download, Trash2 } from 'lucide-react-native';
import { useBibleStore } from '@/lib/stores/bible-store';
import { TRANSLATIONS } from '@/lib/bible/constants';
import {
  isTranslationDownloaded,
  downloadTranslation,
  deleteTranslation,
  DownloadProgress,
} from '@/lib/bible/offline';

interface TranslationPickerProps {
  onClose?: () => void;
}

export function TranslationPicker({ onClose }: TranslationPickerProps) {
  const { currentTranslation, setTranslation } = useBibleStore();
  const [downloadStatus, setDownloadStatus] = useState<Record<string, boolean>>({});
  const [downloading, setDownloading] = useState<string | null>(null);
  const [progress, setProgress] = useState<DownloadProgress | null>(null);

  // Check download status on mount
  useEffect(() => {
    const checkStatus = async () => {
      const status: Record<string, boolean> = {};
      for (const t of TRANSLATIONS) {
        status[t.id] = await isTranslationDownloaded(t.id);
      }
      setDownloadStatus(status);
    };
    checkStatus();
  }, []);

  const handleSelect = (translationId: string) => {
    setTranslation(translationId);
    onClose?.();
  };

  const handleDownload = async (translationId: string) => {
    setDownloading(translationId);
    try {
      await downloadTranslation(translationId, setProgress);
      setDownloadStatus((prev) => ({ ...prev, [translationId]: true }));
    } catch (error) {
      console.error('Download failed:', error);
    } finally {
      setDownloading(null);
      setProgress(null);
    }
  };

  const handleDelete = async (translationId: string) => {
    try {
      await deleteTranslation(translationId);
      setDownloadStatus((prev) => ({ ...prev, [translationId]: false }));
    } catch (error) {
      console.error('Delete failed:', error);
    }
  };

  return (
    <View className="p-4">
      <Text className="text-foreground text-base font-semibold mb-3">
        Translation
      </Text>

      {TRANSLATIONS.map((translation) => {
        const isSelected = currentTranslation === translation.id;
        const isDownloaded = downloadStatus[translation.id];
        const isDownloading = downloading === translation.id;

        return (
          <View
            key={translation.id}
            className="flex-row items-center justify-between py-3 border-b border-border"
          >
            <Pressable
              onPress={() => handleSelect(translation.id)}
              className="flex-1 flex-row items-center"
            >
              <View
                className={`w-5 h-5 rounded-full mr-3 items-center justify-center ${
                  isSelected ? 'bg-primary' : 'border border-muted-foreground'
                }`}
              >
                {isSelected && <Check size={12} className="text-primary-foreground" />}
              </View>
              <View>
                <Text className="text-foreground text-base">{translation.name}</Text>
                <Text className="text-muted-foreground text-xs">
                  {isDownloaded ? 'Available offline' : 'Online only'}
                </Text>
              </View>
            </Pressable>

            {/* Download/Delete button */}
            {isDownloading ? (
              <View className="flex-row items-center gap-2">
                <ActivityIndicator size="small" />
                <Text className="text-muted-foreground text-xs">
                  {progress?.progress ?? 0}%
                </Text>
              </View>
            ) : isDownloaded ? (
              <Pressable
                onPress={() => handleDelete(translation.id)}
                className="p-2"
              >
                <Trash2 size={18} className="text-muted-foreground" />
              </Pressable>
            ) : (
              <Pressable
                onPress={() => handleDownload(translation.id)}
                className="p-2"
              >
                <Download size={18} className="text-primary" />
              </Pressable>
            )}
          </View>
        );
      })}

      <Text className="text-muted-foreground text-xs mt-3">
        Downloaded translations work without internet connection
      </Text>
    </View>
  );
}
```

Now integrate these pickers into the Bible reader. Add a settings button to the header that opens a bottom sheet with font size and translation options.

Update `app/bible/[book]/[chapter].tsx` to add settings:

```typescript
// Add imports
import { Settings } from 'lucide-react-native';
import BottomSheet, { BottomSheetView, BottomSheetBackdrop } from '@gorhom/bottom-sheet';
import { FontSizePicker } from '@/components/bible/font-size-picker';
import { TranslationPicker } from '@/components/bible/translation-picker';

// Add ref for settings sheet
const settingsSheetRef = useRef<BottomSheet>(null);
const [settingsTab, setSettingsTab] = useState<'font' | 'translation'>('font');

// Add settings button to header
headerRight: () => (
  <View className="flex-row">
    <Pressable onPress={() => router.push('/search')} className="p-2">
      <Search size={22} className="text-foreground" />
    </Pressable>
    <Pressable onPress={() => settingsSheetRef.current?.expand()} className="p-2">
      <Settings size={22} className="text-foreground" />
    </Pressable>
  </View>
),

// Add settings bottom sheet to JSX
<BottomSheet
  ref={settingsSheetRef}
  index={-1}
  snapPoints={['50%']}
  enablePanDownToClose
  backdropComponent={(props) => (
    <BottomSheetBackdrop {...props} disappearsOnIndex={-1} appearsOnIndex={0} />
  )}
>
  <BottomSheetView>
    {/* Tab buttons */}
    <View className="flex-row border-b border-border">
      <Pressable
        onPress={() => setSettingsTab('font')}
        className={`flex-1 py-3 items-center ${
          settingsTab === 'font' ? 'border-b-2 border-primary' : ''
        }`}
      >
        <Text
          className={settingsTab === 'font' ? 'text-primary font-medium' : 'text-muted-foreground'}
        >
          Font Size
        </Text>
      </Pressable>
      <Pressable
        onPress={() => setSettingsTab('translation')}
        className={`flex-1 py-3 items-center ${
          settingsTab === 'translation' ? 'border-b-2 border-primary' : ''
        }`}
      >
        <Text
          className={settingsTab === 'translation' ? 'text-primary font-medium' : 'text-muted-foreground'}
        >
          Translation
        </Text>
      </Pressable>
    </View>

    {/* Tab content */}
    {settingsTab === 'font' ? (
      <FontSizePicker onClose={() => settingsSheetRef.current?.close()} />
    ) : (
      <TranslationPicker onClose={() => settingsSheetRef.current?.close()} />
    )}
  </BottomSheetView>
</BottomSheet>
```
  </action>
  <verify>
- FontSizePicker shows 3 size options
- TranslationPicker shows available translations
- Download button triggers download flow
- Settings accessible via gear icon in Bible reader
- Font size changes immediately visible in reader
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Font size and translation settings integrated into Bible reader</done>
</task>

</tasks>

<verification>
1. TypeScript check: `npx tsc --noEmit` - no errors
2. Font size: Open settings, change font size, see verses update
3. Close and reopen app: Font size should persist
4. Translation download: Tap download icon, see progress, verify completion
5. Offline test: Enable airplane mode, verify downloaded translation works
</verification>

<success_criteria>
- User can adjust font size (BIBL-07)
- Font size persists across app restarts
- User can download translation for offline (BIBL-08)
- Downloaded translation works offline (BIBL-09)
- Download progress shown during download
- Can delete downloaded translations
- Settings accessible from Bible reader header
</success_criteria>

<output>
After completion, create `.planning/phases/03-bible-reading/03-09-SUMMARY.md`
</output>
