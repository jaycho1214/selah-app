---
phase: 03-bible-reading
plan: 09
type: execute
wave: 5
depends_on: ["03-01", "03-02", "03-03", "03-04"]
files_modified:
  - components/bible/font-size-picker.tsx
  - components/bible/translation-picker.tsx
  - components/bible/download-manager.tsx
  - lib/bible/offline.ts
  - app/bible/[book]/[chapter].tsx
autonomous: true

must_haves:
  truths:
    - "User can adjust font size (small/medium/large)"
    - "Font size persists across sessions"
    - "User can download a translation for offline use"
    - "Downloaded translation works without network"
    - "App detects when a newer version of a downloaded translation is available"
    - "User can update a downloaded translation to the latest version"
  artifacts:
    - path: "components/bible/font-size-picker.tsx"
      provides: "Font size selection UI"
      exports: ["FontSizePicker"]
    - path: "lib/bible/offline.ts"
      provides: "Offline Bible data management with versioning"
      exports: ["downloadTranslation", "isTranslationDownloaded", "getOfflineVerses", "checkForUpdates", "updateTranslation", "getRemoteTranslations"]
  key_links:
    - from: "components/bible/font-size-picker.tsx"
      to: "lib/stores/settings-store.ts"
      via: "useSettingsStore"
      pattern: "useSettingsStore"
    - from: "lib/bible/offline.ts"
      to: "lib/db/client.ts"
      via: "db for SQLite operations"
      pattern: "import.*db.*from"
    - from: "lib/bible/offline.ts"
      to: "expo-file-system"
      via: "FileSystem.downloadAsync"
      pattern: "FileSystem"
---

<objective>
Implement font size adjustment and offline reading with translation downloads.

Purpose: Font size accessibility (BIBL-07) and offline reading (BIBL-08, BIBL-09) are essential for a Bible app. Users read in various conditions and may not always have network.

Output: Font size picker, translation download manager, offline-first data loading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-bible-reading/03-RESEARCH.md
@.planning/phases/03-bible-reading/03-01-SUMMARY.md
@.planning/phases/03-bible-reading/03-02-SUMMARY.md
@.planning/phases/03-bible-reading/03-03-SUMMARY.md
@.planning/phases/03-bible-reading/03-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FontSizePicker component</name>
  <files>components/bible/font-size-picker.tsx</files>
  <action>
Create `components/bible/font-size-picker.tsx`:

```typescript
import { View, Text, Pressable } from 'react-native';
import { useSettingsStore, FontSize, FONT_SIZES } from '@/lib/stores/settings-store';

const FONT_SIZE_OPTIONS: { id: FontSize; label: string }[] = [
  { id: 'small', label: 'A' },
  { id: 'medium', label: 'A' },
  { id: 'large', label: 'A' },
];

interface FontSizePickerProps {
  onClose?: () => void;
}

export function FontSizePicker({ onClose }: FontSizePickerProps) {
  const { fontSize, setFontSize } = useSettingsStore();

  const handleSelect = (size: FontSize) => {
    setFontSize(size);
    onClose?.();
  };

  return (
    <View className="p-4">
      <Text className="text-foreground text-base font-semibold mb-3">
        Font Size
      </Text>
      <View className="flex-row gap-3">
        {FONT_SIZE_OPTIONS.map((option) => {
          const sizes = FONT_SIZES[option.id];
          const isSelected = fontSize === option.id;
          return (
            <Pressable
              key={option.id}
              onPress={() => handleSelect(option.id)}
              className={`flex-1 py-3 rounded-lg items-center justify-center ${
                isSelected ? 'bg-primary' : 'bg-muted'
              }`}
            >
              <Text
                className={isSelected ? 'text-primary-foreground' : 'text-foreground'}
                style={{ fontSize: sizes.text }}
              >
                {option.label}
              </Text>
              <Text
                className={`text-xs mt-1 ${
                  isSelected ? 'text-primary-foreground/70' : 'text-muted-foreground'
                }`}
              >
                {option.id}
              </Text>
            </Pressable>
          );
        })}
      </View>

      {/* Preview */}
      <View className="mt-4 p-3 bg-muted rounded-lg">
        <Text className="text-muted-foreground text-xs mb-1">Preview</Text>
        <Text
          className="text-foreground"
          style={{
            fontSize: FONT_SIZES[fontSize].text,
            lineHeight: FONT_SIZES[fontSize].lineHeight,
          }}
        >
          For God so loved the world, that he gave his only begotten Son...
        </Text>
      </View>
    </View>
  );
}
```

The picker shows three size options with live preview. The selected size is highlighted and persists via the settings store.
  </action>
  <verify>
- File exports `FontSizePicker` component
- Three size options (small, medium, large)
- Uses useSettingsStore for state
- Preview shows current font size
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>FontSizePicker component for text size adjustment</done>
</task>

<task type="auto">
  <name>Task 2: Create offline Bible data manager with versioning</name>
  <files>lib/bible/offline.ts</files>
  <action>
Install expo-file-system if not already:
```bash
npx expo install expo-file-system
```

Create `lib/bible/offline.ts`:

```typescript
import * as FileSystem from 'expo-file-system';
import { db } from '@/lib/db/client';
import { translations, verses } from '@/lib/db/schema';
import { eq, and } from 'drizzle-orm';
import type { BibleBook } from './types';

const API_URL = process.env.EXPO_PUBLIC_API_URL ?? 'https://api.selah.app';

export interface DownloadProgress {
  status: 'idle' | 'downloading' | 'processing' | 'complete' | 'error';
  progress: number; // 0-100
  error?: string;
}

export interface RemoteTranslation {
  id: string;
  name: string;
  version: string;
  size: number; // bytes
}

export interface TranslationUpdate {
  id: string;
  name: string;
  currentVersion: string;
  newVersion: string;
}

/**
 * Fetch available translations from server with version info
 * GET /api/bible/translations -> { translations: RemoteTranslation[] }
 */
export async function getRemoteTranslations(): Promise<RemoteTranslation[]> {
  const response = await fetch(`${API_URL}/api/bible/translations`);
  if (!response.ok) {
    throw new Error(`Failed to fetch translations: ${response.status}`);
  }
  const data = await response.json();
  return data.translations;
}

/**
 * Check if a translation is downloaded for offline use
 */
export async function isTranslationDownloaded(translationId: string): Promise<boolean> {
  const result = await db
    .select()
    .from(translations)
    .where(eq(translations.id, translationId))
    .limit(1);
  return result.length > 0 && result[0].downloadedAt !== null;
}

/**
 * Get list of downloaded translations with their versions
 */
export async function getDownloadedTranslations() {
  return db.select().from(translations);
}

/**
 * Check for updates to downloaded translations
 * Compares local version against server version
 */
export async function checkForUpdates(): Promise<TranslationUpdate[]> {
  const remote = await getRemoteTranslations();
  const local = await getDownloadedTranslations();

  const updates: TranslationUpdate[] = [];

  for (const remoteTranslation of remote) {
    const localTranslation = local.find((t) => t.id === remoteTranslation.id);

    // Only check downloaded translations
    if (localTranslation && localTranslation.version !== remoteTranslation.version) {
      updates.push({
        id: remoteTranslation.id,
        name: remoteTranslation.name,
        currentVersion: localTranslation.version,
        newVersion: remoteTranslation.version,
      });
    }
  }

  return updates;
}

/**
 * Download a translation for offline use
 * Server endpoint: GET /api/bible/{id}.json
 * Expected response: { id, name, version, verses: Array<{ book, chapter, verse, text }> }
 */
export async function downloadTranslation(
  translationId: string,
  onProgress?: (progress: DownloadProgress) => void
): Promise<void> {
  try {
    onProgress?.({ status: 'downloading', progress: 0 });

    const url = `${API_URL}/api/bible/${translationId}.json`;
    const fileUri = `${FileSystem.cacheDirectory}${translationId}.json`;

    const downloadResult = await FileSystem.downloadAsync(url, fileUri, {
      md5: false,
    });

    if (downloadResult.status !== 200) {
      throw new Error(`Download failed with status ${downloadResult.status}`);
    }

    onProgress?.({ status: 'processing', progress: 50 });

    // Read and parse the file
    const content = await FileSystem.readAsStringAsync(downloadResult.uri);
    const data = JSON.parse(content) as {
      id: string;
      name: string;
      version: string;  // e.g., "2024.1"
      verses: Array<{
        book: BibleBook;
        chapter: number;
        verse: number;
        text: string;
      }>;
    };

    // Insert into SQLite in batches
    const batchSize = 500;
    const totalVerses = data.verses.length;

    for (let i = 0; i < totalVerses; i += batchSize) {
      const batch = data.verses.slice(i, i + batchSize);

      await db.transaction(async (tx) => {
        for (const v of batch) {
          await tx
            .insert(verses)
            .values({
              id: `${translationId}:${v.book}:${v.chapter}:${v.verse}`,
              translationId,
              book: v.book,
              chapter: v.chapter,
              verse: v.verse,
              text: v.text,
            })
            .onConflictDoUpdate({
              target: verses.id,
              set: { text: v.text },
            });
        }
      });

      const progress = 50 + Math.round((i / totalVerses) * 50);
      onProgress?.({ status: 'processing', progress });
    }

    // Mark translation as downloaded with version
    await db
      .insert(translations)
      .values({
        id: translationId,
        name: data.name,
        version: data.version,
        downloadedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: translations.id,
        set: {
          name: data.name,
          version: data.version,
          downloadedAt: new Date()
        },
      });

    // Cleanup temp file
    await FileSystem.deleteAsync(fileUri, { idempotent: true });

    onProgress?.({ status: 'complete', progress: 100 });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    onProgress?.({ status: 'error', progress: 0, error: message });
    throw error;
  }
}

/**
 * Update a downloaded translation to the latest version
 * Deletes existing verses and re-downloads fresh data
 */
export async function updateTranslation(
  translationId: string,
  onProgress?: (progress: DownloadProgress) => void
): Promise<void> {
  // Delete existing verses first
  await db.delete(verses).where(eq(verses.translationId, translationId));

  // Re-download with new version
  await downloadTranslation(translationId, onProgress);
}

/**
 * Delete a downloaded translation
 */
export async function deleteTranslation(translationId: string): Promise<void> {
  await db.delete(verses).where(eq(verses.translationId, translationId));
  await db.delete(translations).where(eq(translations.id, translationId));
}

/**
 * Get verses from offline storage
 * NOTE: Uses Drizzle's and() combinator for multiple WHERE conditions
 */
export async function getOfflineVerses(
  translationId: string,
  book: BibleBook,
  chapter: number
) {
  return db
    .select()
    .from(verses)
    .where(
      and(
        eq(verses.translationId, translationId),
        eq(verses.book, book),
        eq(verses.chapter, chapter)
      )
    )
    .orderBy(verses.verse);
}

/**
 * Check if specific chapter is available offline
 * NOTE: Uses Drizzle's and() combinator for multiple WHERE conditions
 */
export async function isChapterAvailable(
  translationId: string,
  book: BibleBook,
  chapter: number
): Promise<boolean> {
  const result = await db
    .select({ id: verses.id })
    .from(verses)
    .where(
      and(
        eq(verses.translationId, translationId),
        eq(verses.book, book),
        eq(verses.chapter, chapter)
      )
    )
    .limit(1);
  return result.length > 0;
}
```

**Backend API Requirements:**

1. `GET /api/bible/translations` - List available translations with versions:
   ```json
   {
     "translations": [
       { "id": "KJV", "name": "King James Version", "version": "2024.1", "size": 4200000 },
       { "id": "ASV", "name": "American Standard", "version": "2024.1", "size": 3900000 }
     ]
   }
   ```

2. `GET /api/bible/{id}.json` - Download translation data:
   ```json
   {
     "id": "KJV",
     "name": "King James Version",
     "version": "2024.1",
     "verses": [{ "book": "GENESIS", "chapter": 1, "verse": 1, "text": "..." }, ...]
   }
   ```

IMPORTANT: Drizzle ORM requires using the `and()` function to combine multiple WHERE conditions. Do NOT use JavaScript's `&&` operator - it will not work correctly with Drizzle's query builder.
  </action>
  <verify>
- File exports: downloadTranslation, updateTranslation, checkForUpdates, getRemoteTranslations, getOfflineVerses, isTranslationDownloaded
- Uses expo-file-system for downloads
- Uses Drizzle db for SQLite operations
- Uses `and()` combinator (NOT `&&`) for multiple WHERE conditions
- Stores and compares version strings
- Handles progress callbacks
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Offline Bible data manager with versioned downloads and update checking</done>
</task>

<task type="auto">
  <name>Task 3: Integrate font size and translation picker into reader</name>
  <files>components/bible/translation-picker.tsx, app/bible/[book]/[chapter].tsx</files>
  <action>
Create `components/bible/translation-picker.tsx`:

```typescript
import { useState, useEffect } from 'react';
import { View, Text, Pressable, ActivityIndicator } from 'react-native';
import { Check, Download, Trash2, RefreshCw } from 'lucide-react-native';
import { useBibleStore } from '@/lib/stores/bible-store';
import {
  getRemoteTranslations,
  getDownloadedTranslations,
  downloadTranslation,
  updateTranslation,
  deleteTranslation,
  DownloadProgress,
  RemoteTranslation,
} from '@/lib/bible/offline';

interface TranslationPickerProps {
  onClose?: () => void;
}

interface LocalTranslation {
  id: string;
  name: string;
  version: string;
  downloadedAt: Date | null;
}

export function TranslationPicker({ onClose }: TranslationPickerProps) {
  const { currentTranslation, setTranslation } = useBibleStore();
  const [remoteTranslations, setRemoteTranslations] = useState<RemoteTranslation[]>([]);
  const [localTranslations, setLocalTranslations] = useState<LocalTranslation[]>([]);
  const [downloading, setDownloading] = useState<string | null>(null);
  const [progress, setProgress] = useState<DownloadProgress | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch remote translations and check local status on mount
  useEffect(() => {
    const loadData = async () => {
      try {
        const [remote, local] = await Promise.all([
          getRemoteTranslations(),
          getDownloadedTranslations(),
        ]);
        setRemoteTranslations(remote);
        setLocalTranslations(local);
      } catch (error) {
        console.error('Failed to load translations:', error);
      } finally {
        setLoading(false);
      }
    };
    loadData();
  }, []);

  const getLocalTranslation = (id: string) =>
    localTranslations.find((t) => t.id === id);

  const isDownloaded = (id: string) => {
    const local = getLocalTranslation(id);
    return local && local.downloadedAt !== null;
  };

  const hasUpdate = (id: string) => {
    const local = getLocalTranslation(id);
    const remote = remoteTranslations.find((t) => t.id === id);
    return local && remote && local.version !== remote.version;
  };

  const handleSelect = (translationId: string) => {
    setTranslation(translationId);
    onClose?.();
  };

  const handleDownload = async (translationId: string) => {
    setDownloading(translationId);
    try {
      await downloadTranslation(translationId, setProgress);
      // Refresh local translations list
      const local = await getDownloadedTranslations();
      setLocalTranslations(local);
    } catch (error) {
      console.error('Download failed:', error);
    } finally {
      setDownloading(null);
      setProgress(null);
    }
  };

  const handleUpdate = async (translationId: string) => {
    setDownloading(translationId);
    try {
      await updateTranslation(translationId, setProgress);
      // Refresh local translations list
      const local = await getDownloadedTranslations();
      setLocalTranslations(local);
    } catch (error) {
      console.error('Update failed:', error);
    } finally {
      setDownloading(null);
      setProgress(null);
    }
  };

  const handleDelete = async (translationId: string) => {
    try {
      await deleteTranslation(translationId);
      setLocalTranslations((prev) => prev.filter((t) => t.id !== translationId));
    } catch (error) {
      console.error('Delete failed:', error);
    }
  };

  if (loading) {
    return (
      <View className="p-4 items-center">
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return (
    <View className="p-4">
      <Text className="text-foreground text-base font-semibold mb-3">
        Translation
      </Text>

      {remoteTranslations.map((translation) => {
        const isSelected = currentTranslation === translation.id;
        const downloaded = isDownloaded(translation.id);
        const updateAvailable = hasUpdate(translation.id);
        const isDownloading = downloading === translation.id;
        const local = getLocalTranslation(translation.id);

        return (
          <View
            key={translation.id}
            className="flex-row items-center justify-between py-3 border-b border-border"
          >
            <Pressable
              onPress={() => handleSelect(translation.id)}
              className="flex-1 flex-row items-center"
            >
              <View
                className={`w-5 h-5 rounded-full mr-3 items-center justify-center ${
                  isSelected ? 'bg-primary' : 'border border-muted-foreground'
                }`}
              >
                {isSelected && <Check size={12} className="text-primary-foreground" />}
              </View>
              <View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-foreground text-base">{translation.name}</Text>
                  {updateAvailable && (
                    <View className="bg-primary/20 px-1.5 py-0.5 rounded">
                      <Text className="text-primary text-xs font-medium">Update</Text>
                    </View>
                  )}
                </View>
                <Text className="text-muted-foreground text-xs">
                  {downloaded
                    ? `v${local?.version} Â· Available offline`
                    : 'Online only'}
                </Text>
              </View>
            </Pressable>

            {/* Action buttons */}
            {isDownloading ? (
              <View className="flex-row items-center gap-2">
                <ActivityIndicator size="small" />
                <Text className="text-muted-foreground text-xs">
                  {progress?.progress ?? 0}%
                </Text>
              </View>
            ) : updateAvailable ? (
              <View className="flex-row items-center">
                <Pressable
                  onPress={() => handleUpdate(translation.id)}
                  className="p-2"
                >
                  <RefreshCw size={18} className="text-primary" />
                </Pressable>
                <Pressable
                  onPress={() => handleDelete(translation.id)}
                  className="p-2"
                >
                  <Trash2 size={18} className="text-muted-foreground" />
                </Pressable>
              </View>
            ) : downloaded ? (
              <Pressable
                onPress={() => handleDelete(translation.id)}
                className="p-2"
              >
                <Trash2 size={18} className="text-muted-foreground" />
              </Pressable>
            ) : (
              <Pressable
                onPress={() => handleDownload(translation.id)}
                className="p-2"
              >
                <Download size={18} className="text-primary" />
              </Pressable>
            )}
          </View>
        );
      })}

      <Text className="text-muted-foreground text-xs mt-3">
        Downloaded translations work without internet connection
      </Text>
    </View>
  );
}
```

Now integrate these pickers into the Bible reader. Add a settings button to the header that opens a bottom sheet with font size and translation options.

Update `app/bible/[book]/[chapter].tsx` to add settings:

```typescript
// Add imports
import { Settings } from 'lucide-react-native';
import BottomSheet, { BottomSheetView, BottomSheetBackdrop } from '@gorhom/bottom-sheet';
import { FontSizePicker } from '@/components/bible/font-size-picker';
import { TranslationPicker } from '@/components/bible/translation-picker';

// Add ref for settings sheet
const settingsSheetRef = useRef<BottomSheet>(null);
const [settingsTab, setSettingsTab] = useState<'font' | 'translation'>('font');

// Add settings button to header
headerRight: () => (
  <View className="flex-row">
    <Pressable onPress={() => router.push('/search')} className="p-2">
      <Search size={22} className="text-foreground" />
    </Pressable>
    <Pressable onPress={() => settingsSheetRef.current?.expand()} className="p-2">
      <Settings size={22} className="text-foreground" />
    </Pressable>
  </View>
),

// Add settings bottom sheet to JSX
<BottomSheet
  ref={settingsSheetRef}
  index={-1}
  snapPoints={['50%']}
  enablePanDownToClose
  backdropComponent={(props) => (
    <BottomSheetBackdrop {...props} disappearsOnIndex={-1} appearsOnIndex={0} />
  )}
>
  <BottomSheetView>
    {/* Tab buttons */}
    <View className="flex-row border-b border-border">
      <Pressable
        onPress={() => setSettingsTab('font')}
        className={`flex-1 py-3 items-center ${
          settingsTab === 'font' ? 'border-b-2 border-primary' : ''
        }`}
      >
        <Text
          className={settingsTab === 'font' ? 'text-primary font-medium' : 'text-muted-foreground'}
        >
          Font Size
        </Text>
      </Pressable>
      <Pressable
        onPress={() => setSettingsTab('translation')}
        className={`flex-1 py-3 items-center ${
          settingsTab === 'translation' ? 'border-b-2 border-primary' : ''
        }`}
      >
        <Text
          className={settingsTab === 'translation' ? 'text-primary font-medium' : 'text-muted-foreground'}
        >
          Translation
        </Text>
      </Pressable>
    </View>

    {/* Tab content */}
    {settingsTab === 'font' ? (
      <FontSizePicker onClose={() => settingsSheetRef.current?.close()} />
    ) : (
      <TranslationPicker onClose={() => settingsSheetRef.current?.close()} />
    )}
  </BottomSheetView>
</BottomSheet>
```

NOTE: This task modifies `app/bible/[book]/[chapter].tsx` which was created in Plan 03-04. The depends_on includes 03-04 to ensure proper ordering.
  </action>
  <verify>
- FontSizePicker shows 3 size options
- TranslationPicker shows available translations
- Download button triggers download flow
- Settings accessible via gear icon in Bible reader
- Font size changes immediately visible in reader
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Font size and translation settings integrated into Bible reader</done>
</task>

</tasks>

<verification>
1. TypeScript check: `npx tsc --noEmit` - no errors
2. Font size: Open settings, change font size, see verses update
3. Close and reopen app: Font size should persist
4. Translation download: Tap download icon, see progress, verify completion
5. Offline test: Enable airplane mode, verify downloaded translation works
6. Version display: Downloaded translation shows version number (e.g., "v2024.1")
7. Update detection: If server has newer version, "Update" badge appears
8. Update flow: Tap refresh icon, translation re-downloads with new version
</verification>

<success_criteria>
- User can adjust font size (BIBL-07)
- Font size persists across app restarts
- User can download translation for offline (BIBL-08)
- Downloaded translation works offline (BIBL-09)
- Download progress shown during download
- Can delete downloaded translations
- Settings accessible from Bible reader header
- Downloaded translations display version number
- Update badge appears when newer version available on server
- User can update a translation to latest version
</success_criteria>

<output>
After completion, create `.planning/phases/03-bible-reading/03-09-SUMMARY.md`
</output>
