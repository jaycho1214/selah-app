---
phase: 03-bible-reading
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - components/bible/chapter-view.tsx
  - components/bible/verse-item.tsx
  - lib/relay/__generated__/ChapterViewQuery.graphql.ts
autonomous: true

must_haves:
  truths:
    - "Chapter displays all verses in order"
    - "Verse numbers are visible and aligned"
    - "Highlights appear as background colors on verses"
    - "Tap on verse triggers onPress callback"
    - "Long-press on verse triggers onLongPress callback"
    - "Chapter loads from SQLite when translation is downloaded and offline"
  artifacts:
    - path: "components/bible/chapter-view.tsx"
      provides: "FlashList rendering of chapter verses"
      exports: ["ChapterView"]
    - path: "components/bible/verse-item.tsx"
      provides: "Individual verse with highlight support"
      exports: ["VerseItem"]
  key_links:
    - from: "components/bible/chapter-view.tsx"
      to: "@shopify/flash-list"
      via: "FlashList component"
      pattern: "FlashList"
    - from: "components/bible/verse-item.tsx"
      to: "lib/stores/settings-store.ts"
      via: "useSettingsStore for font size"
      pattern: "useSettingsStore"
    - from: "components/bible/chapter-view.tsx"
      to: "lib/stores/annotations-store.ts"
      via: "useAnnotationsStore for highlights"
      pattern: "useAnnotationsStore"
    - from: "components/bible/chapter-view.tsx"
      to: "lib/bible/offline.ts"
      via: "getOfflineVerses fallback when offline"
      pattern: "getOfflineVerses|isTranslationDownloaded"
---

<objective>
Create the chapter reading view with performant verse rendering using FlashList.

Purpose: The chapter view is the core reading experience. It must render verses efficiently (Psalm 119 has 176 verses), support highlight colors, and respond to tap/long-press for verse actions. It also needs offline fallback support (BIBL-09).

Output: ChapterView component with FlashList and VerseItem component with styling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-bible-reading/03-RESEARCH.md
@.planning/phases/03-bible-reading/03-01-SUMMARY.md
@.planning/phases/03-bible-reading/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install FlashList</name>
  <files>package.json</files>
  <action>
Install @shopify/flash-list:
```bash
npx expo install @shopify/flash-list
```

FlashList provides cell recycling for 10x better performance than FlatList. It requires `estimatedItemSize` prop for optimal recycling. We'll use ~80 for verse items (varies with font size).
  </action>
  <verify>
- `npm ls @shopify/flash-list` shows package installed (v2.x)
  </verify>
  <done>FlashList installed for performant list rendering</done>
</task>

<task type="auto">
  <name>Task 2: Create VerseItem component</name>
  <files>components/bible/verse-item.tsx</files>
  <action>
Create `components/bible/verse-item.tsx`:

```typescript
import { Pressable, Text, View } from 'react-native';
import { useSettingsStore, FONT_SIZES } from '@/lib/stores/settings-store';

interface VerseItemProps {
  verse: {
    id: string;
    verse: number;
    text: string;
  };
  highlightColor?: string | null;
  isBookmarked?: boolean;
  onPress: () => void;
  onLongPress: () => void;
}

export function VerseItem({
  verse,
  highlightColor,
  isBookmarked,
  onPress,
  onLongPress,
}: VerseItemProps) {
  const { fontSize } = useSettingsStore();
  const sizes = FONT_SIZES[fontSize];

  return (
    <Pressable
      onPress={onPress}
      onLongPress={onLongPress}
      delayLongPress={400}
      className="flex-row gap-3 py-2 px-4 active:bg-muted/50"
      style={highlightColor ? { backgroundColor: highlightColor + '26' } : undefined}
    >
      {/* Verse number */}
      <Text
        className="text-muted-foreground font-semibold"
        style={{
          fontSize: sizes.verse,
          minWidth: 28,
          textAlign: 'right',
        }}
      >
        {verse.verse}
      </Text>

      {/* Verse text */}
      <View className="flex-1 flex-row flex-wrap">
        <Text
          className="text-foreground"
          style={{
            fontSize: sizes.text,
            lineHeight: sizes.lineHeight,
          }}
        >
          {verse.text}
        </Text>
        {isBookmarked && (
          <Text className="text-primary ml-1" style={{ fontSize: sizes.verse }}>
            *
          </Text>
        )}
      </View>
    </Pressable>
  );
}
```

Design notes:
- Highlight color uses 26 (15%) opacity suffix for subtle background
- Verse number right-aligned with fixed minWidth for alignment
- `delayLongPress={400}` prevents accidental long-press during scroll
- `active:bg-muted/50` provides tap feedback
- Bookmark indicator is a simple asterisk (will be replaced with icon later)
  </action>
  <verify>
- File exports `VerseItem` component
- Component accepts verse, highlightColor, isBookmarked, onPress, onLongPress props
- Uses useSettingsStore for font size
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>VerseItem component renders verse with highlight and interaction support</done>
</task>

<task type="auto">
  <name>Task 3: Create ChapterView component with FlashList and offline fallback</name>
  <files>components/bible/chapter-view.tsx</files>
  <action>
Create `components/bible/chapter-view.tsx`:

```typescript
import { useCallback, useMemo, useState, useEffect } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import { graphql, useLazyLoadQuery } from 'react-relay';
import NetInfo from '@react-native-community/netinfo';
import { VerseItem } from './verse-item';
import { useAnnotationsStore } from '@/lib/stores/annotations-store';
import { useBibleStore } from '@/lib/stores/bible-store';
import { useSettingsStore, FONT_SIZES } from '@/lib/stores/settings-store';
import { isTranslationDownloaded, getOfflineVerses } from '@/lib/bible/offline';
import type { BibleBook } from '@/lib/bible/types';
import type { ChapterViewQuery } from '@/lib/relay/__generated__/ChapterViewQuery.graphql';

const chapterQuery = graphql`
  query ChapterViewQuery($translation: String!, $book: BibleBook!, $chapter: Int!) {
    bibleVersesByReference(translationId: $translation, book: $book, chapter: $chapter) {
      id
      verse
      text
    }
  }
`;

interface Verse {
  id: string;
  verse: number;
  text: string;
}

interface ChapterViewProps {
  book: BibleBook;
  chapter: number;
  onVersePress?: (verseId: string, verseText?: string) => void;
  onVerseLongPress?: (verseId: string, verseText?: string) => void;
}

export function ChapterView({
  book,
  chapter,
  onVersePress,
  onVerseLongPress,
}: ChapterViewProps) {
  const { currentTranslation } = useBibleStore();
  const { highlights, bookmarks } = useAnnotationsStore();
  const { fontSize } = useSettingsStore();

  // Track offline state and availability
  const [isOffline, setIsOffline] = useState(false);
  const [offlineAvailable, setOfflineAvailable] = useState(false);
  const [offlineVerses, setOfflineVerses] = useState<Verse[] | null>(null);

  // Check network status and offline availability
  useEffect(() => {
    const checkOfflineStatus = async () => {
      const netState = await NetInfo.fetch();
      const offline = !netState.isConnected;
      setIsOffline(offline);

      const downloaded = await isTranslationDownloaded(currentTranslation);
      setOfflineAvailable(downloaded);

      // If offline and translation is downloaded, load from SQLite
      if (offline && downloaded) {
        const verses = await getOfflineVerses(currentTranslation, book, chapter);
        setOfflineVerses(verses as Verse[]);
      } else {
        setOfflineVerses(null);
      }
    };

    checkOfflineStatus();

    // Subscribe to network changes
    const unsubscribe = NetInfo.addEventListener((state) => {
      setIsOffline(!state.isConnected);
      if (!state.isConnected) {
        checkOfflineStatus();
      }
    });

    return () => unsubscribe();
  }, [currentTranslation, book, chapter]);

  // Only use Relay when online or when offline data not available
  // Note: useLazyLoadQuery will suspend, so we wrap this component in Suspense
  const shouldUseRelay = !isOffline || !offlineAvailable;

  // Conditionally render the Relay version or offline version
  if (isOffline && offlineAvailable && offlineVerses) {
    return (
      <ChapterViewContent
        verses={offlineVerses}
        highlights={highlights}
        bookmarks={bookmarks}
        fontSize={fontSize}
        onVersePress={onVersePress}
        onVerseLongPress={onVerseLongPress}
      />
    );
  }

  // Online mode - use Relay
  return (
    <ChapterViewRelay
      book={book}
      chapter={chapter}
      currentTranslation={currentTranslation}
      highlights={highlights}
      bookmarks={bookmarks}
      fontSize={fontSize}
      onVersePress={onVersePress}
      onVerseLongPress={onVerseLongPress}
    />
  );
}

// Relay-powered chapter view (for online use)
function ChapterViewRelay({
  book,
  chapter,
  currentTranslation,
  highlights,
  bookmarks,
  fontSize,
  onVersePress,
  onVerseLongPress,
}: {
  book: BibleBook;
  chapter: number;
  currentTranslation: string;
  highlights: Record<string, { color: string }>;
  bookmarks: Record<string, { createdAt: Date }>;
  fontSize: 'small' | 'medium' | 'large';
  onVersePress?: (verseId: string, verseText?: string) => void;
  onVerseLongPress?: (verseId: string, verseText?: string) => void;
}) {
  const data = useLazyLoadQuery<ChapterViewQuery>(
    chapterQuery,
    {
      translation: currentTranslation,
      book,
      chapter,
    },
    { fetchPolicy: 'store-or-network' }
  );

  const verses = data.bibleVersesByReference ?? [];

  return (
    <ChapterViewContent
      verses={verses as Verse[]}
      highlights={highlights}
      bookmarks={bookmarks}
      fontSize={fontSize}
      onVersePress={onVersePress}
      onVerseLongPress={onVerseLongPress}
    />
  );
}

// Shared content renderer
function ChapterViewContent({
  verses,
  highlights,
  bookmarks,
  fontSize,
  onVersePress,
  onVerseLongPress,
}: {
  verses: Verse[];
  highlights: Record<string, { color: string }>;
  bookmarks: Record<string, { createdAt: Date }>;
  fontSize: 'small' | 'medium' | 'large';
  onVersePress?: (verseId: string, verseText?: string) => void;
  onVerseLongPress?: (verseId: string, verseText?: string) => void;
}) {
  // Estimate item size based on font size setting
  const estimatedItemSize = useMemo(() => {
    const sizes = FONT_SIZES[fontSize];
    // Base height + padding + line height for ~2 lines of text
    return sizes.lineHeight * 2 + 16;
  }, [fontSize]);

  const renderItem = useCallback(
    ({ item }: { item: Verse }) => {
      const highlight = highlights[item.id];
      const bookmark = bookmarks[item.id];

      return (
        <VerseItem
          verse={item}
          highlightColor={highlight?.color}
          isBookmarked={!!bookmark}
          onPress={() => onVersePress?.(item.id, item.text)}
          onLongPress={() => onVerseLongPress?.(item.id, item.text)}
        />
      );
    },
    [highlights, bookmarks, onVersePress, onVerseLongPress]
  );

  const keyExtractor = useCallback((item: Verse) => item.id, []);

  if (verses.length === 0) {
    return (
      <View className="flex-1 items-center justify-center">
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return (
    <View className="flex-1">
      <FlashList
        data={verses}
        renderItem={renderItem}
        keyExtractor={keyExtractor}
        estimatedItemSize={estimatedItemSize}
        contentContainerStyle={{ paddingVertical: 16 }}
      />
    </View>
  );
}
```

After creating the component, run Relay compiler to generate types:
```bash
npm run relay
```

Design notes:
- Uses Relay useLazyLoadQuery for data fetching when online (matches existing app pattern)
- Falls back to getOfflineVerses() from SQLite when offline AND translation is downloaded
- Uses NetInfo to detect network status changes
- `fetchPolicy: 'store-or-network'` uses cached data when available
- Highlights and bookmarks are looked up by verse ID from store
- FlashList estimatedItemSize adjusts based on font size
- Empty state shows loading indicator (verses loading from network)
- Callbacks now pass verseText as second parameter (for VerseActions)
  </action>
  <verify>
- File exports `ChapterView` component
- Relay query defined with graphql tag
- `npm run relay` generates ChapterViewQuery.graphql.ts without errors
- Component uses FlashList with estimatedItemSize
- Component checks isTranslationDownloaded and falls back to getOfflineVerses
- onVersePress and onVerseLongPress callbacks include verseText parameter
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ChapterView fetches verses via Relay online, SQLite offline, and renders with FlashList</done>
</task>

</tasks>

<verification>
1. TypeScript check: `npx tsc --noEmit` - no errors
2. Relay compiler: `npm run relay` - generates query types
3. Visual test: Import ChapterView in a screen to verify verses render
4. Offline test: Download a translation, enable airplane mode, verify chapter still loads
</verification>

<success_criteria>
- FlashList installed and working
- VerseItem component renders verse number, text, highlight background
- ChapterView fetches verses via Relay GraphQL when online
- ChapterView loads from SQLite when offline and translation downloaded (BIBL-09)
- Verses display in order with correct styling
- Highlight colors appear as subtle backgrounds (15% opacity)
- Font size from settings store affects verse text size
- Tap and long-press callbacks work on verses and include verse text
</success_criteria>

<output>
After completion, create `.planning/phases/03-bible-reading/03-03-SUMMARY.md`
</output>
