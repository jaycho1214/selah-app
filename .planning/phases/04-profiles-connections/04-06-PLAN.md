---
phase: 04-profiles-connections
plan: 06
type: execute
wave: 5
depends_on: ["04-05"]
files_modified:
  - app/followers/[userId].tsx
  - app/following/[userId].tsx
  - components/user/user-row.tsx
  - components/user/user-list.tsx
  - lib/relay/__generated__/followersListQuery.graphql.ts
  - lib/relay/__generated__/followingListQuery.graphql.ts
  - lib/relay/__generated__/UserRow_user.graphql.ts
autonomous: true

must_haves:
  truths:
    - "User can view list of followers for any profile"
    - "User can view list of following for any profile"
    - "Lists show user avatar, name, and username"
    - "Tapping a user in list navigates to their profile"
    - "Lists support infinite scroll for many users"
    - "Empty state shows when list is empty"
  artifacts:
    - path: "app/followers/[userId].tsx"
      provides: "Followers list screen"
      exports: ["default"]
    - path: "app/following/[userId].tsx"
      provides: "Following list screen"
      exports: ["default"]
    - path: "components/user/user-row.tsx"
      provides: "User row item for lists"
      exports: ["UserRow"]
    - path: "components/user/user-list.tsx"
      provides: "Generic user list with FlashList"
      exports: ["UserList"]
  key_links:
    - from: "app/followers/[userId].tsx"
      to: "components/user/user-list.tsx"
      via: "UserList import"
      pattern: "import.*UserList"
    - from: "components/user/user-list.tsx"
      to: "@shopify/flash-list"
      via: "FlashList import"
      pattern: "import.*FlashList"
    - from: "components/user/user-row.tsx"
      to: "app/user/[username].tsx"
      via: "navigation on press"
      pattern: "router\\.push.*user"
---

<objective>
Create followers and following list screens with user rows.

Purpose: Implements CONN-03 (view followers) and CONN-04 (view following)
Output: Two list screens with infinite scroll and navigation
</objective>

<execution_context>
@/Users/jay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-profiles-connections/04-CONTEXT.md
@.planning/phases/04-profiles-connections/04-RESEARCH.md
@.planning/phases/04-profiles-connections/04-05-SUMMARY.md
@components/bible/bookmark-item.tsx (row item pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserRow component with fragment</name>
  <files>components/user/user-row.tsx</files>
  <action>
Create user row item for follower/following lists:

**Fragment**:
```graphql
fragment UserRow_user on User {
  id
  username
  name
  bio
  image { url }
  followedAt
  ...FollowButton_user
}
```

**Component** (matching selah-web list row design):
```typescript
import { Pressable, View, StyleSheet } from 'react-native';
import { useFragment } from 'react-relay';
import { graphql } from 'relay-runtime';
import { router } from 'expo-router';
import * as Haptics from 'expo-haptics';

import { Text } from '@/components/ui/text';
import { UserAvatar } from '@/components/user/user-avatar';
import { FollowButton } from '@/components/user/follow-button';
import { useColors } from '@/hooks/use-colors';
import { useSession } from '@/components/providers/session-provider';
import type { UserRow_user$key } from '@/lib/relay/__generated__/UserRow_user.graphql';

interface UserRowProps {
  userRef: UserRow_user$key;
}

export function UserRow({ userRef }: UserRowProps) {
  const colors = useColors();
  const { session } = useSession();
  const data = useFragment(fragment, userRef);

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    if (data?.username) {
      router.push(`/user/${data.username}`);
    }
  };

  const isOwnProfile = session?.user?.id === data?.id;

  return (
    <Pressable
      onPress={handlePress}
      style={({ pressed }) => [
        styles.container,
        { borderBottomColor: colors.border },
        pressed && { opacity: 0.7 },
      ]}
    >
      <UserAvatar
        imageUrl={data?.image?.url}
        name={data?.name}
        size={48}
      />
      <View style={styles.content}>
        <View style={styles.textContainer}>
          <Text style={[styles.name, { color: colors.text }]} numberOfLines={1}>
            {data?.name || data?.username}
          </Text>
          <Text style={[styles.username, { color: colors.textMuted }]} numberOfLines={1}>
            @{data?.username}
          </Text>
          {data?.bio && (
            <Text style={[styles.bio, { color: colors.textSecondary }]} numberOfLines={2}>
              {data.bio}
            </Text>
          )}
        </View>
        {!isOwnProfile && session?.user && (
          <FollowButton userRef={data} />
        )}
      </View>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    padding: 16,
    borderBottomWidth: StyleSheet.hairlineWidth,
  },
  content: {
    flex: 1,
    flexDirection: 'row',
    marginLeft: 12,
    alignItems: 'flex-start',
  },
  textContainer: {
    flex: 1,
    marginRight: 12,
  },
  name: {
    fontSize: 16,
    fontWeight: '600',
  },
  username: {
    fontSize: 14,
    marginTop: 2,
  },
  bio: {
    fontSize: 14,
    marginTop: 4,
    lineHeight: 18,
  },
});
```

Include FollowButton on each row (except own profile).
  </action>
  <verify>`npx relay-compiler && npx tsc --noEmit`</verify>
  <done>UserRow displays avatar, name, username, bio, and follow button</done>
</task>

<task type="auto">
  <name>Task 2: Create UserList component with FlashList</name>
  <files>components/user/user-list.tsx</files>
  <action>
Create generic user list component:

```typescript
import { FlashList } from '@shopify/flash-list';
import { View, StyleSheet, ActivityIndicator } from 'react-native';
import Animated, { FadeIn } from 'react-native-reanimated';
import { Users } from 'lucide-react-native';

import { Text } from '@/components/ui/text';
import { UserRow } from '@/components/user/user-row';
import { useColors } from '@/hooks/use-colors';

interface UserListProps {
  users: ReadonlyArray<{ readonly node: { readonly id: string } | null }>;
  hasNext: boolean;
  isLoadingNext: boolean;
  loadNext: () => void;
  emptyMessage: string;
  emptySubMessage?: string;
}

export function UserList({
  users,
  hasNext,
  isLoadingNext,
  loadNext,
  emptyMessage,
  emptySubMessage,
}: UserListProps) {
  const colors = useColors();

  if (users.length === 0) {
    return (
      <Animated.View
        entering={FadeIn.duration(300)}
        style={styles.emptyContainer}
      >
        <View
          style={[
            styles.emptyIconContainer,
            { backgroundColor: colors.surfaceElevated },
          ]}
        >
          <Users size={32} color={colors.textMuted} strokeWidth={1.5} />
        </View>
        <Text style={[styles.emptyTitle, { color: colors.text }]}>
          {emptyMessage}
        </Text>
        {emptySubMessage && (
          <Text style={[styles.emptySubtitle, { color: colors.textMuted }]}>
            {emptySubMessage}
          </Text>
        )}
      </Animated.View>
    );
  }

  return (
    <FlashList
      data={users}
      renderItem={({ item }) =>
        item.node ? <UserRow userRef={item.node} /> : null
      }
      keyExtractor={(item) => item.node?.id ?? ''}
      estimatedItemSize={88}  // Approximate row height
      onEndReached={() => {
        if (hasNext && !isLoadingNext) {
          loadNext();
        }
      }}
      onEndReachedThreshold={0.5}
      ListFooterComponent={
        isLoadingNext ? (
          <View style={styles.footer}>
            <ActivityIndicator />
          </View>
        ) : null
      }
    />
  );
}

const styles = StyleSheet.create({
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 64,
    paddingHorizontal: 32,
  },
  emptyIconContainer: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 20,
  },
  emptyTitle: {
    fontSize: 18,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  emptySubtitle: {
    fontSize: 14,
    textAlign: 'center',
    lineHeight: 20,
  },
  footer: {
    paddingVertical: 20,
    alignItems: 'center',
  },
});
```

Note: FlashList requires keyExtractor for stable recycling.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>UserList renders users with FlashList, handles empty state and loading</done>
</task>

<task type="auto">
  <name>Task 3: Create followers and following list screens</name>
  <files>app/followers/[userId].tsx, app/following/[userId].tsx</files>
  <action>
Create both list screens with pagination:

**app/followers/[userId].tsx**:
```typescript
import { Suspense } from 'react';
import { View, ActivityIndicator } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Stack, useLocalSearchParams } from 'expo-router';
import { graphql, useLazyLoadQuery, usePaginationFragment } from 'react-relay';

import { UserList } from '@/components/user/user-list';

export default function FollowersScreen() {
  const { userId } = useLocalSearchParams<{ userId: string }>();

  return (
    <SafeAreaView edges={['bottom']} style={{ flex: 1 }}>
      <Stack.Screen options={{ title: 'Followers' }} />
      <Suspense fallback={<LoadingSpinner />}>
        <FollowersContent userId={userId} />
      </Suspense>
    </SafeAreaView>
  );
}

function FollowersContent({ userId }: { userId: string }) {
  const data = useLazyLoadQuery(
    graphql`
      query followersListQuery($userId: ID!) {
        node(id: $userId) {
          ... on User {
            ...followersListFragment
          }
        }
      }
    `,
    { userId }
  );

  const { data: fragmentData, loadNext, hasNext, isLoadingNext } =
    usePaginationFragment(
      graphql`
        fragment followersListFragment on User
        @argumentDefinitions(
          first: { type: "Int", defaultValue: 20 }
          after: { type: "String" }
        )
        @refetchable(queryName: "followersListPaginationQuery") {
          followers(first: $first, after: $after)
          @connection(key: "followersList_followers") {
            edges {
              node {
                id
                ...UserRow_user
              }
            }
          }
        }
      `,
      data.node
    );

  const followers = fragmentData?.followers?.edges ?? [];

  return (
    <UserList
      users={followers}
      hasNext={hasNext}
      isLoadingNext={isLoadingNext}
      loadNext={() => loadNext(20)}
      emptyMessage="No followers yet"
      emptySubMessage="When people follow this user, they'll appear here"
    />
  );
}
```

**app/following/[userId].tsx**:
Same structure but with `following` connection:
```graphql
fragment followingListFragment on User
@argumentDefinitions(
  first: { type: "Int", defaultValue: 20 }
  after: { type: "String" }
)
@refetchable(queryName: "followingListPaginationQuery") {
  following(first: $first, after: $after)
  @connection(key: "followingList_following") {
    edges {
      node {
        id
        ...UserRow_user
      }
    }
  }
}
```

Empty message: "Not following anyone" / "When this user follows people, they'll appear here"

**Note**: The GraphQL schema needs `followers` and `following` connection fields on User.
If not available, these screens will show errors. This may require backend work.
Check schema and document if backend changes needed.
  </action>
  <verify>Navigate to /followers/[userId], see list or empty state</verify>
  <done>Both list screens render with pagination and navigation to profiles</done>
</task>

</tasks>

<verification>
1. `npx relay-compiler` generates all types (may error if schema missing followers/following)
2. `npx tsc --noEmit` passes
3. From profile screen, tap "X Followers" count
4. Followers list loads with user rows
5. Tap a user row, navigates to their profile
6. Scroll to bottom, more users load (if available)
7. Same flow for Following list
8. Empty state shows appropriate message
9. Follow button on rows works correctly
</verification>

<success_criteria>
- /followers/[userId] shows list of followers
- /following/[userId] shows list of following
- User rows show avatar, name, username, bio
- Tapping row navigates to user profile
- Infinite scroll loads more users
- Empty states display when lists empty
- Follow buttons on rows work (if not own profile)
</success_criteria>

<output>
After completion, create `.planning/phases/04-profiles-connections/04-06-SUMMARY.md`

**Important**: Document if `followers`/`following` connection fields don't exist in schema.
This would require backend work to add these fields before full functionality.
</output>
